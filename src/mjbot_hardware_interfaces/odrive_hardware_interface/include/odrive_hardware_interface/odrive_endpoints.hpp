/*
* This file was autogenerated using the "odrivetool generate-code" feature.
*
* The file matches a specific firmware version. If you add/remove/rename any
* properties exposed by the ODrive, this file needs to be regenerated, otherwise
* the ODrive will ignore all commands.
*/

#ifndef __ODRIVE_ENDPOINTS_HPP
#define __ODRIVE_ENDPOINTS_HPP


namespace odrive {
    
static constexpr const uint16_t json_crc = 0xebfb;

static constexpr const uint16_t per_axis_offset = 304;

enum { 
    ERROR = 1,
    VBUS_VOLTAGE = 2,
    IBUS = 3,
    IBUS_REPORT_FILTER_K = 4,
    SERIAL_NUMBER = 5,
    HW_VERSION_MAJOR = 6,
    HW_VERSION_MINOR = 7,
    HW_VERSION_VARIANT = 8,
    FW_VERSION_MAJOR = 9,
    FW_VERSION_MINOR = 10,
    FW_VERSION_REVISION = 11,
    FW_VERSION_UNRELEASED = 12,
    BRAKE_RESISTOR_ARMED = 13,
    BRAKE_RESISTOR_SATURATED = 14,
    BRAKE_RESISTOR_CURRENT = 15,
    N_EVT_SAMPLING = 16,
    N_EVT_CONTROL_LOOP = 17,
    TASK_TIMERS_ARMED = 18,
    TASK_TIMES__SAMPLING__START_TIME = 19,
    TASK_TIMES__SAMPLING__END_TIME = 20,
    TASK_TIMES__SAMPLING__LENGTH = 21,
    TASK_TIMES__SAMPLING__MAX_LENGTH = 22,
    TASK_TIMES__CONTROL_LOOP_MISC__START_TIME = 23,
    TASK_TIMES__CONTROL_LOOP_MISC__END_TIME = 24,
    TASK_TIMES__CONTROL_LOOP_MISC__LENGTH = 25,
    TASK_TIMES__CONTROL_LOOP_MISC__MAX_LENGTH = 26,
    TASK_TIMES__CONTROL_LOOP_CHECKS__START_TIME = 27,
    TASK_TIMES__CONTROL_LOOP_CHECKS__END_TIME = 28,
    TASK_TIMES__CONTROL_LOOP_CHECKS__LENGTH = 29,
    TASK_TIMES__CONTROL_LOOP_CHECKS__MAX_LENGTH = 30,
    TASK_TIMES__DC_CALIB_WAIT__START_TIME = 31,
    TASK_TIMES__DC_CALIB_WAIT__END_TIME = 32,
    TASK_TIMES__DC_CALIB_WAIT__LENGTH = 33,
    TASK_TIMES__DC_CALIB_WAIT__MAX_LENGTH = 34,
    SYSTEM_STATS__UPTIME = 35,
    SYSTEM_STATS__MIN_HEAP_SPACE = 36,
    SYSTEM_STATS__MAX_STACK_USAGE_AXIS = 37,
    SYSTEM_STATS__MAX_STACK_USAGE_USB = 38,
    SYSTEM_STATS__MAX_STACK_USAGE_UART = 39,
    SYSTEM_STATS__MAX_STACK_USAGE_CAN = 40,
    SYSTEM_STATS__MAX_STACK_USAGE_STARTUP = 41,
    SYSTEM_STATS__MAX_STACK_USAGE_ANALOG = 42,
    SYSTEM_STATS__STACK_SIZE_AXIS = 43,
    SYSTEM_STATS__STACK_SIZE_USB = 44,
    SYSTEM_STATS__STACK_SIZE_UART = 45,
    SYSTEM_STATS__STACK_SIZE_STARTUP = 46,
    SYSTEM_STATS__STACK_SIZE_CAN = 47,
    SYSTEM_STATS__STACK_SIZE_ANALOG = 48,
    SYSTEM_STATS__PRIO_AXIS = 49,
    SYSTEM_STATS__PRIO_USB = 50,
    SYSTEM_STATS__PRIO_UART = 51,
    SYSTEM_STATS__PRIO_STARTUP = 52,
    SYSTEM_STATS__PRIO_CAN = 53,
    SYSTEM_STATS__PRIO_ANALOG = 54,
    SYSTEM_STATS__USB__RX_CNT = 55,
    SYSTEM_STATS__USB__TX_CNT = 56,
    SYSTEM_STATS__USB__TX_OVERRUN_CNT = 57,
    SYSTEM_STATS__I2C__ADDR = 58,
    SYSTEM_STATS__I2C__ADDR_MATCH_CNT = 59,
    SYSTEM_STATS__I2C__RX_CNT = 60,
    SYSTEM_STATS__I2C__ERROR_CNT = 61,
    USER_CONFIG_LOADED = 62,
    MISCONFIGURED = 63,
    OSCILLOSCOPE__SIZE = 64,
    CAN__ERROR = 68,
    CAN__CONFIG__BAUD_RATE = 69,
    CAN__CONFIG__PROTOCOL = 70,
    TEST_PROPERTY = 71,
    OTP_VALID = 72,
    CONFIG__ENABLE_UART_A = 73,
    CONFIG__ENABLE_UART_B = 74,
    CONFIG__ENABLE_UART_C = 75,
    CONFIG__UART_A_BAUDRATE = 76,
    CONFIG__UART_B_BAUDRATE = 77,
    CONFIG__UART_C_BAUDRATE = 78,
    CONFIG__ENABLE_CAN_A = 79,
    CONFIG__ENABLE_I2C_A = 80,
    CONFIG__USB_CDC_PROTOCOL = 81,
    CONFIG__UART0_PROTOCOL = 82,
    CONFIG__UART1_PROTOCOL = 83,
    CONFIG__UART2_PROTOCOL = 84,
    CONFIG__MAX_REGEN_CURRENT = 85,
    CONFIG__BRAKE_RESISTANCE = 86,
    CONFIG__ENABLE_BRAKE_RESISTOR = 87,
    CONFIG__DC_BUS_UNDERVOLTAGE_TRIP_LEVEL = 88,
    CONFIG__DC_BUS_OVERVOLTAGE_TRIP_LEVEL = 89,
    CONFIG__ENABLE_DC_BUS_OVERVOLTAGE_RAMP = 90,
    CONFIG__DC_BUS_OVERVOLTAGE_RAMP_START = 91,
    CONFIG__DC_BUS_OVERVOLTAGE_RAMP_END = 92,
    CONFIG__DC_MAX_POSITIVE_CURRENT = 93,
    CONFIG__DC_MAX_NEGATIVE_CURRENT = 94,
    CONFIG__ERROR_GPIO_PIN = 95,
    CONFIG__GPIO3_ANALOG_MAPPING__MIN = 97,
    CONFIG__GPIO3_ANALOG_MAPPING__MAX = 98,
    CONFIG__GPIO4_ANALOG_MAPPING__MIN = 100,
    CONFIG__GPIO4_ANALOG_MAPPING__MAX = 101,
    CONFIG__GPIO1_MODE = 102,
    CONFIG__GPIO2_MODE = 103,
    CONFIG__GPIO3_MODE = 104,
    CONFIG__GPIO4_MODE = 105,
    CONFIG__GPIO5_MODE = 106,
    CONFIG__GPIO6_MODE = 107,
    CONFIG__GPIO7_MODE = 108,
    CONFIG__GPIO8_MODE = 109,
    CONFIG__GPIO9_MODE = 110,
    CONFIG__GPIO10_MODE = 111,
    CONFIG__GPIO11_MODE = 112,
    CONFIG__GPIO12_MODE = 113,
    CONFIG__GPIO13_MODE = 114,
    CONFIG__GPIO14_MODE = 115,
    CONFIG__GPIO15_MODE = 116,
    CONFIG__GPIO16_MODE = 117,
    CONFIG__GPIO1_PWM_MAPPING__MIN = 119,
    CONFIG__GPIO1_PWM_MAPPING__MAX = 120,
    CONFIG__GPIO2_PWM_MAPPING__MIN = 122,
    CONFIG__GPIO2_PWM_MAPPING__MAX = 123,
    CONFIG__GPIO3_PWM_MAPPING__MIN = 125,
    CONFIG__GPIO3_PWM_MAPPING__MAX = 126,
    CONFIG__GPIO4_PWM_MAPPING__MIN = 128,
    CONFIG__GPIO4_PWM_MAPPING__MAX = 129,
    ERASE_CONFIGURATION = 746,
    REBOOT = 747,
    ENTER_DFU_MODE = 748,
    CLEAR_ERRORS = 759,

    // Per-Axis endpoints (to be used with read_axis_property and write_axis_property)
    AXIS__ERROR = 130,
    AXIS__STEP_DIR_ACTIVE = 131,
    AXIS__LAST_DRV_FAULT = 132,
    AXIS__STEPS = 133,
    AXIS__CURRENT_STATE = 134,
    AXIS__REQUESTED_STATE = 135,
    AXIS__IS_HOMED = 136,
    AXIS__CONFIG__STARTUP_MOTOR_CALIBRATION = 137,
    AXIS__CONFIG__STARTUP_ENCODER_INDEX_SEARCH = 138,
    AXIS__CONFIG__STARTUP_ENCODER_OFFSET_CALIBRATION = 139,
    AXIS__CONFIG__STARTUP_CLOSED_LOOP_CONTROL = 140,
    AXIS__CONFIG__STARTUP_HOMING = 141,
    AXIS__CONFIG__ENABLE_STEP_DIR = 142,
    AXIS__CONFIG__STEP_DIR_ALWAYS_ON = 143,
    AXIS__CONFIG__ENABLE_SENSORLESS_MODE = 144,
    AXIS__CONFIG__WATCHDOG_TIMEOUT = 145,
    AXIS__CONFIG__ENABLE_WATCHDOG = 146,
    AXIS__CONFIG__STEP_GPIO_PIN = 147,
    AXIS__CONFIG__DIR_GPIO_PIN = 148,
    AXIS__CONFIG__CALIBRATION_LOCKIN__CURRENT = 149,
    AXIS__CONFIG__CALIBRATION_LOCKIN__RAMP_TIME = 150,
    AXIS__CONFIG__CALIBRATION_LOCKIN__RAMP_DISTANCE = 151,
    AXIS__CONFIG__CALIBRATION_LOCKIN__ACCEL = 152,
    AXIS__CONFIG__CALIBRATION_LOCKIN__VEL = 153,
    AXIS__CONFIG__SENSORLESS_RAMP__CURRENT = 154,
    AXIS__CONFIG__SENSORLESS_RAMP__RAMP_TIME = 155,
    AXIS__CONFIG__SENSORLESS_RAMP__RAMP_DISTANCE = 156,
    AXIS__CONFIG__SENSORLESS_RAMP__ACCEL = 157,
    AXIS__CONFIG__SENSORLESS_RAMP__VEL = 158,
    AXIS__CONFIG__SENSORLESS_RAMP__FINISH_DISTANCE = 159,
    AXIS__CONFIG__SENSORLESS_RAMP__FINISH_ON_VEL = 160,
    AXIS__CONFIG__SENSORLESS_RAMP__FINISH_ON_DISTANCE = 161,
    AXIS__CONFIG__SENSORLESS_RAMP__FINISH_ON_ENC_IDX = 162,
    AXIS__CONFIG__GENERAL_LOCKIN__CURRENT = 163,
    AXIS__CONFIG__GENERAL_LOCKIN__RAMP_TIME = 164,
    AXIS__CONFIG__GENERAL_LOCKIN__RAMP_DISTANCE = 165,
    AXIS__CONFIG__GENERAL_LOCKIN__ACCEL = 166,
    AXIS__CONFIG__GENERAL_LOCKIN__VEL = 167,
    AXIS__CONFIG__GENERAL_LOCKIN__FINISH_DISTANCE = 168,
    AXIS__CONFIG__GENERAL_LOCKIN__FINISH_ON_VEL = 169,
    AXIS__CONFIG__GENERAL_LOCKIN__FINISH_ON_DISTANCE = 170,
    AXIS__CONFIG__GENERAL_LOCKIN__FINISH_ON_ENC_IDX = 171,
    AXIS__CONFIG__CAN__NODE_ID = 172,
    AXIS__CONFIG__CAN__IS_EXTENDED = 173,
    AXIS__CONFIG__CAN__HEARTBEAT_RATE_MS = 174,
    AXIS__CONFIG__CAN__ENCODER_RATE_MS = 175,
    AXIS__MOTOR__LAST_ERROR_TIME = 176,
    AXIS__MOTOR__ERROR = 177,
    AXIS__MOTOR__IS_ARMED = 178,
    AXIS__MOTOR__IS_CALIBRATED = 179,
    AXIS__MOTOR__CURRENT_MEAS_PHA = 180,
    AXIS__MOTOR__CURRENT_MEAS_PHB = 181,
    AXIS__MOTOR__CURRENT_MEAS_PHC = 182,
    AXIS__MOTOR__DC_CALIB_PHA = 183,
    AXIS__MOTOR__DC_CALIB_PHB = 184,
    AXIS__MOTOR__DC_CALIB_PHC = 185,
    AXIS__MOTOR__I_BUS = 186,
    AXIS__MOTOR__PHASE_CURRENT_REV_GAIN = 187,
    AXIS__MOTOR__EFFECTIVE_CURRENT_LIM = 188,
    AXIS__MOTOR__MAX_ALLOWED_CURRENT = 189,
    AXIS__MOTOR__MAX_DC_CALIB = 190,
    AXIS__MOTOR__FET_THERMISTOR__TEMPERATURE = 191,
    AXIS__MOTOR__FET_THERMISTOR__CONFIG__TEMP_LIMIT_LOWER = 192,
    AXIS__MOTOR__FET_THERMISTOR__CONFIG__TEMP_LIMIT_UPPER = 193,
    AXIS__MOTOR__FET_THERMISTOR__CONFIG__ENABLED = 194,
    AXIS__MOTOR__MOTOR_THERMISTOR__TEMPERATURE = 195,
    AXIS__MOTOR__MOTOR_THERMISTOR__CONFIG__GPIO_PIN = 196,
    AXIS__MOTOR__MOTOR_THERMISTOR__CONFIG__POLY_COEFFICIENT_0 = 197,
    AXIS__MOTOR__MOTOR_THERMISTOR__CONFIG__POLY_COEFFICIENT_1 = 198,
    AXIS__MOTOR__MOTOR_THERMISTOR__CONFIG__POLY_COEFFICIENT_2 = 199,
    AXIS__MOTOR__MOTOR_THERMISTOR__CONFIG__POLY_COEFFICIENT_3 = 200,
    AXIS__MOTOR__MOTOR_THERMISTOR__CONFIG__TEMP_LIMIT_LOWER = 201,
    AXIS__MOTOR__MOTOR_THERMISTOR__CONFIG__TEMP_LIMIT_UPPER = 202,
    AXIS__MOTOR__MOTOR_THERMISTOR__CONFIG__ENABLED = 203,
    AXIS__MOTOR__CURRENT_CONTROL__P_GAIN = 204,
    AXIS__MOTOR__CURRENT_CONTROL__I_GAIN = 205,
    AXIS__MOTOR__CURRENT_CONTROL__I_MEASURED_REPORT_FILTER_K = 206,
    AXIS__MOTOR__CURRENT_CONTROL__ID_SETPOINT = 207,
    AXIS__MOTOR__CURRENT_CONTROL__IQ_SETPOINT = 208,
    AXIS__MOTOR__CURRENT_CONTROL__VD_SETPOINT = 209,
    AXIS__MOTOR__CURRENT_CONTROL__VQ_SETPOINT = 210,
    AXIS__MOTOR__CURRENT_CONTROL__PHASE = 211,
    AXIS__MOTOR__CURRENT_CONTROL__PHASE_VEL = 212,
    AXIS__MOTOR__CURRENT_CONTROL__IALPHA_MEASURED = 213,
    AXIS__MOTOR__CURRENT_CONTROL__IBETA_MEASURED = 214,
    AXIS__MOTOR__CURRENT_CONTROL__ID_MEASURED = 215,
    AXIS__MOTOR__CURRENT_CONTROL__IQ_MEASURED = 216,
    AXIS__MOTOR__CURRENT_CONTROL__POWER = 217,
    AXIS__MOTOR__CURRENT_CONTROL__V_CURRENT_CONTROL_INTEGRAL_D = 218,
    AXIS__MOTOR__CURRENT_CONTROL__V_CURRENT_CONTROL_INTEGRAL_Q = 219,
    AXIS__MOTOR__CURRENT_CONTROL__FINAL_V_ALPHA = 220,
    AXIS__MOTOR__CURRENT_CONTROL__FINAL_V_BETA = 221,
    AXIS__MOTOR__N_EVT_CURRENT_MEASUREMENT = 222,
    AXIS__MOTOR__N_EVT_PWM_UPDATE = 223,
    AXIS__MOTOR__CONFIG__PRE_CALIBRATED = 224,
    AXIS__MOTOR__CONFIG__POLE_PAIRS = 225,
    AXIS__MOTOR__CONFIG__CALIBRATION_CURRENT = 226,
    AXIS__MOTOR__CONFIG__RESISTANCE_CALIB_MAX_VOLTAGE = 227,
    AXIS__MOTOR__CONFIG__PHASE_INDUCTANCE = 228,
    AXIS__MOTOR__CONFIG__PHASE_RESISTANCE = 229,
    AXIS__MOTOR__CONFIG__TORQUE_CONSTANT = 230,
    AXIS__MOTOR__CONFIG__MOTOR_TYPE = 231,
    AXIS__MOTOR__CONFIG__CURRENT_LIM = 232,
    AXIS__MOTOR__CONFIG__CURRENT_LIM_MARGIN = 233,
    AXIS__MOTOR__CONFIG__TORQUE_LIM = 234,
    AXIS__MOTOR__CONFIG__INVERTER_TEMP_LIMIT_LOWER = 235,
    AXIS__MOTOR__CONFIG__INVERTER_TEMP_LIMIT_UPPER = 236,
    AXIS__MOTOR__CONFIG__REQUESTED_CURRENT_RANGE = 237,
    AXIS__MOTOR__CONFIG__CURRENT_CONTROL_BANDWIDTH = 238,
    AXIS__MOTOR__CONFIG__ACIM_GAIN_MIN_FLUX = 239,
    AXIS__MOTOR__CONFIG__ACIM_AUTOFLUX_MIN_ID = 240,
    AXIS__MOTOR__CONFIG__ACIM_AUTOFLUX_ENABLE = 241,
    AXIS__MOTOR__CONFIG__ACIM_AUTOFLUX_ATTACK_GAIN = 242,
    AXIS__MOTOR__CONFIG__ACIM_AUTOFLUX_DECAY_GAIN = 243,
    AXIS__MOTOR__CONFIG__R_WL_FF_ENABLE = 244,
    AXIS__MOTOR__CONFIG__BEMF_FF_ENABLE = 245,
    AXIS__MOTOR__CONFIG__I_BUS_HARD_MIN = 246,
    AXIS__MOTOR__CONFIG__I_BUS_HARD_MAX = 247,
    AXIS__MOTOR__CONFIG__I_LEAK_MAX = 248,
    AXIS__MOTOR__CONFIG__DC_CALIB_TAU = 249,
    AXIS__CONTROLLER__ERROR = 250,
    AXIS__CONTROLLER__LAST_ERROR_TIME = 251,
    AXIS__CONTROLLER__INPUT_POS = 252,
    AXIS__CONTROLLER__INPUT_VEL = 253,
    AXIS__CONTROLLER__INPUT_TORQUE = 254,
    AXIS__CONTROLLER__POS_SETPOINT = 255,
    AXIS__CONTROLLER__VEL_SETPOINT = 256,
    AXIS__CONTROLLER__TORQUE_SETPOINT = 257,
    AXIS__CONTROLLER__TRAJECTORY_DONE = 258,
    AXIS__CONTROLLER__VEL_INTEGRATOR_TORQUE = 259,
    AXIS__CONTROLLER__ANTICOGGING_VALID = 260,
    AXIS__CONTROLLER__AUTOTUNING_PHASE = 261,
    AXIS__CONTROLLER__CONFIG__GAIN_SCHEDULING_WIDTH = 262,
    AXIS__CONTROLLER__CONFIG__ENABLE_VEL_LIMIT = 263,
    AXIS__CONTROLLER__CONFIG__ENABLE_TORQUE_MODE_VEL_LIMIT = 264,
    AXIS__CONTROLLER__CONFIG__ENABLE_GAIN_SCHEDULING = 265,
    AXIS__CONTROLLER__CONFIG__ENABLE_OVERSPEED_ERROR = 266,
    AXIS__CONTROLLER__CONFIG__CONTROL_MODE = 267,
    AXIS__CONTROLLER__CONFIG__INPUT_MODE = 268,
    AXIS__CONTROLLER__CONFIG__POS_GAIN = 269,
    AXIS__CONTROLLER__CONFIG__VEL_GAIN = 270,
    AXIS__CONTROLLER__CONFIG__VEL_INTEGRATOR_GAIN = 271,
    AXIS__CONTROLLER__CONFIG__VEL_LIMIT = 272,
    AXIS__CONTROLLER__CONFIG__VEL_LIMIT_TOLERANCE = 273,
    AXIS__CONTROLLER__CONFIG__VEL_RAMP_RATE = 274,
    AXIS__CONTROLLER__CONFIG__TORQUE_RAMP_RATE = 275,
    AXIS__CONTROLLER__CONFIG__CIRCULAR_SETPOINTS = 276,
    AXIS__CONTROLLER__CONFIG__CIRCULAR_SETPOINT_RANGE = 277,
    AXIS__CONTROLLER__CONFIG__STEPS_PER_CIRCULAR_RANGE = 278,
    AXIS__CONTROLLER__CONFIG__HOMING_SPEED = 279,
    AXIS__CONTROLLER__CONFIG__INERTIA = 280,
    AXIS__CONTROLLER__CONFIG__AXIS_TO_MIRROR = 281,
    AXIS__CONTROLLER__CONFIG__MIRROR_RATIO = 282,
    AXIS__CONTROLLER__CONFIG__TORQUE_MIRROR_RATIO = 283,
    AXIS__CONTROLLER__CONFIG__LOAD_ENCODER_AXIS = 284,
    AXIS__CONTROLLER__CONFIG__INPUT_FILTER_BANDWIDTH = 285,
    AXIS__CONTROLLER__CONFIG__ANTICOGGING__INDEX = 286,
    AXIS__CONTROLLER__CONFIG__ANTICOGGING__PRE_CALIBRATED = 287,
    AXIS__CONTROLLER__CONFIG__ANTICOGGING__CALIB_ANTICOGGING = 288,
    AXIS__CONTROLLER__CONFIG__ANTICOGGING__CALIB_POS_THRESHOLD = 289,
    AXIS__CONTROLLER__CONFIG__ANTICOGGING__CALIB_VEL_THRESHOLD = 290,
    AXIS__CONTROLLER__CONFIG__ANTICOGGING__COGGING_RATIO = 291,
    AXIS__CONTROLLER__CONFIG__ANTICOGGING__ANTICOGGING_ENABLED = 292,
    AXIS__CONTROLLER__CONFIG__MECHANICAL_POWER_BANDWIDTH = 293,
    AXIS__CONTROLLER__CONFIG__ELECTRICAL_POWER_BANDWIDTH = 294,
    AXIS__CONTROLLER__CONFIG__SPINOUT_MECHANICAL_POWER_THRESHOLD = 295,
    AXIS__CONTROLLER__CONFIG__SPINOUT_ELECTRICAL_POWER_THRESHOLD = 296,
    AXIS__CONTROLLER__AUTOTUNING__FREQUENCY = 297,
    AXIS__CONTROLLER__AUTOTUNING__POS_AMPLITUDE = 298,
    AXIS__CONTROLLER__AUTOTUNING__VEL_AMPLITUDE = 299,
    AXIS__CONTROLLER__AUTOTUNING__TORQUE_AMPLITUDE = 300,
    AXIS__CONTROLLER__MECHANICAL_POWER = 301,
    AXIS__CONTROLLER__ELECTRICAL_POWER = 302,
    AXIS__CONTROLLER__START_ANTICOGGING_CALIBRATION = 306,
    AXIS__ENCODER__ERROR = 307,
    AXIS__ENCODER__IS_READY = 308,
    AXIS__ENCODER__INDEX_FOUND = 309,
    AXIS__ENCODER__SHADOW_COUNT = 310,
    AXIS__ENCODER__COUNT_IN_CPR = 311,
    AXIS__ENCODER__INTERPOLATION = 312,
    AXIS__ENCODER__PHASE = 313,
    AXIS__ENCODER__POS_ESTIMATE = 314,
    AXIS__ENCODER__POS_ESTIMATE_COUNTS = 315,
    AXIS__ENCODER__POS_CIRCULAR = 316,
    AXIS__ENCODER__POS_CPR_COUNTS = 317,
    AXIS__ENCODER__DELTA_POS_CPR_COUNTS = 318,
    AXIS__ENCODER__HALL_STATE = 319,
    AXIS__ENCODER__VEL_ESTIMATE = 320,
    AXIS__ENCODER__VEL_ESTIMATE_COUNTS = 321,
    AXIS__ENCODER__CALIB_SCAN_RESPONSE = 322,
    AXIS__ENCODER__POS_ABS = 323,
    AXIS__ENCODER__SPI_ERROR_RATE = 324,
    AXIS__ENCODER__CONFIG__MODE = 325,
    AXIS__ENCODER__CONFIG__USE_INDEX = 326,
    AXIS__ENCODER__CONFIG__INDEX_OFFSET = 327,
    AXIS__ENCODER__CONFIG__USE_INDEX_OFFSET = 328,
    AXIS__ENCODER__CONFIG__FIND_IDX_ON_LOCKIN_ONLY = 329,
    AXIS__ENCODER__CONFIG__ABS_SPI_CS_GPIO_PIN = 330,
    AXIS__ENCODER__CONFIG__CPR = 331,
    AXIS__ENCODER__CONFIG__PHASE_OFFSET = 332,
    AXIS__ENCODER__CONFIG__PHASE_OFFSET_FLOAT = 333,
    AXIS__ENCODER__CONFIG__DIRECTION = 334,
    AXIS__ENCODER__CONFIG__PRE_CALIBRATED = 335,
    AXIS__ENCODER__CONFIG__ENABLE_PHASE_INTERPOLATION = 336,
    AXIS__ENCODER__CONFIG__BANDWIDTH = 337,
    AXIS__ENCODER__CONFIG__CALIB_RANGE = 338,
    AXIS__ENCODER__CONFIG__CALIB_SCAN_DISTANCE = 339,
    AXIS__ENCODER__CONFIG__CALIB_SCAN_OMEGA = 340,
    AXIS__ENCODER__CONFIG__IGNORE_ILLEGAL_HALL_STATE = 341,
    AXIS__ENCODER__CONFIG__HALL_POLARITY = 342,
    AXIS__ENCODER__CONFIG__HALL_POLARITY_CALIBRATED = 343,
    AXIS__ENCODER__CONFIG__SINCOS_GPIO_PIN_SIN = 344,
    AXIS__ENCODER__CONFIG__SINCOS_GPIO_PIN_COS = 345,
    AXIS__ACIM_ESTIMATOR__ROTOR_FLUX = 348,
    AXIS__ACIM_ESTIMATOR__SLIP_VEL = 349,
    AXIS__ACIM_ESTIMATOR__PHASE_OFFSET = 350,
    AXIS__ACIM_ESTIMATOR__STATOR_PHASE_VEL = 351,
    AXIS__ACIM_ESTIMATOR__STATOR_PHASE = 352,
    AXIS__ACIM_ESTIMATOR__CONFIG__SLIP_VELOCITY = 353,
    AXIS__SENSORLESS_ESTIMATOR__ERROR = 354,
    AXIS__SENSORLESS_ESTIMATOR__PHASE = 355,
    AXIS__SENSORLESS_ESTIMATOR__PLL_POS = 356,
    AXIS__SENSORLESS_ESTIMATOR__PHASE_VEL = 357,
    AXIS__SENSORLESS_ESTIMATOR__VEL_ESTIMATE = 358,
    AXIS__SENSORLESS_ESTIMATOR__CONFIG__OBSERVER_GAIN = 359,
    AXIS__SENSORLESS_ESTIMATOR__CONFIG__PLL_BANDWIDTH = 360,
    AXIS__SENSORLESS_ESTIMATOR__CONFIG__PM_FLUX_LINKAGE = 361,
    AXIS__TRAP_TRAJ__CONFIG__VEL_LIMIT = 362,
    AXIS__TRAP_TRAJ__CONFIG__ACCEL_LIMIT = 363,
    AXIS__TRAP_TRAJ__CONFIG__DECEL_LIMIT = 364,
    AXIS__MIN_ENDSTOP__ENDSTOP_STATE = 365,
    AXIS__MIN_ENDSTOP__CONFIG__GPIO_NUM = 366,
    AXIS__MIN_ENDSTOP__CONFIG__ENABLED = 367,
    AXIS__MIN_ENDSTOP__CONFIG__OFFSET = 368,
    AXIS__MIN_ENDSTOP__CONFIG__IS_ACTIVE_HIGH = 369,
    AXIS__MIN_ENDSTOP__CONFIG__DEBOUNCE_MS = 370,
    AXIS__MAX_ENDSTOP__ENDSTOP_STATE = 371,
    AXIS__MAX_ENDSTOP__CONFIG__GPIO_NUM = 372,
    AXIS__MAX_ENDSTOP__CONFIG__ENABLED = 373,
    AXIS__MAX_ENDSTOP__CONFIG__OFFSET = 374,
    AXIS__MAX_ENDSTOP__CONFIG__IS_ACTIVE_HIGH = 375,
    AXIS__MAX_ENDSTOP__CONFIG__DEBOUNCE_MS = 376,
    AXIS__MECHANICAL_BRAKE__CONFIG__GPIO_NUM = 377,
    AXIS__MECHANICAL_BRAKE__CONFIG__IS_ACTIVE_LOW = 378,
    AXIS__MECHANICAL_BRAKE__ENGAGE = 379,
    AXIS__MECHANICAL_BRAKE__RELEASE = 380,
    AXIS__TASK_TIMES__THERMISTOR_UPDATE__START_TIME = 381,
    AXIS__TASK_TIMES__THERMISTOR_UPDATE__END_TIME = 382,
    AXIS__TASK_TIMES__THERMISTOR_UPDATE__LENGTH = 383,
    AXIS__TASK_TIMES__THERMISTOR_UPDATE__MAX_LENGTH = 384,
    AXIS__TASK_TIMES__ENCODER_UPDATE__START_TIME = 385,
    AXIS__TASK_TIMES__ENCODER_UPDATE__END_TIME = 386,
    AXIS__TASK_TIMES__ENCODER_UPDATE__LENGTH = 387,
    AXIS__TASK_TIMES__ENCODER_UPDATE__MAX_LENGTH = 388,
    AXIS__TASK_TIMES__SENSORLESS_ESTIMATOR_UPDATE__START_TIME = 389,
    AXIS__TASK_TIMES__SENSORLESS_ESTIMATOR_UPDATE__END_TIME = 390,
    AXIS__TASK_TIMES__SENSORLESS_ESTIMATOR_UPDATE__LENGTH = 391,
    AXIS__TASK_TIMES__SENSORLESS_ESTIMATOR_UPDATE__MAX_LENGTH = 392,
    AXIS__TASK_TIMES__ENDSTOP_UPDATE__START_TIME = 393,
    AXIS__TASK_TIMES__ENDSTOP_UPDATE__END_TIME = 394,
    AXIS__TASK_TIMES__ENDSTOP_UPDATE__LENGTH = 395,
    AXIS__TASK_TIMES__ENDSTOP_UPDATE__MAX_LENGTH = 396,
    AXIS__TASK_TIMES__CAN_HEARTBEAT__START_TIME = 397,
    AXIS__TASK_TIMES__CAN_HEARTBEAT__END_TIME = 398,
    AXIS__TASK_TIMES__CAN_HEARTBEAT__LENGTH = 399,
    AXIS__TASK_TIMES__CAN_HEARTBEAT__MAX_LENGTH = 400,
    AXIS__TASK_TIMES__CONTROLLER_UPDATE__START_TIME = 401,
    AXIS__TASK_TIMES__CONTROLLER_UPDATE__END_TIME = 402,
    AXIS__TASK_TIMES__CONTROLLER_UPDATE__LENGTH = 403,
    AXIS__TASK_TIMES__CONTROLLER_UPDATE__MAX_LENGTH = 404,
    AXIS__TASK_TIMES__OPEN_LOOP_CONTROLLER_UPDATE__START_TIME = 405,
    AXIS__TASK_TIMES__OPEN_LOOP_CONTROLLER_UPDATE__END_TIME = 406,
    AXIS__TASK_TIMES__OPEN_LOOP_CONTROLLER_UPDATE__LENGTH = 407,
    AXIS__TASK_TIMES__OPEN_LOOP_CONTROLLER_UPDATE__MAX_LENGTH = 408,
    AXIS__TASK_TIMES__ACIM_ESTIMATOR_UPDATE__START_TIME = 409,
    AXIS__TASK_TIMES__ACIM_ESTIMATOR_UPDATE__END_TIME = 410,
    AXIS__TASK_TIMES__ACIM_ESTIMATOR_UPDATE__LENGTH = 411,
    AXIS__TASK_TIMES__ACIM_ESTIMATOR_UPDATE__MAX_LENGTH = 412,
    AXIS__TASK_TIMES__MOTOR_UPDATE__START_TIME = 413,
    AXIS__TASK_TIMES__MOTOR_UPDATE__END_TIME = 414,
    AXIS__TASK_TIMES__MOTOR_UPDATE__LENGTH = 415,
    AXIS__TASK_TIMES__MOTOR_UPDATE__MAX_LENGTH = 416,
    AXIS__TASK_TIMES__CURRENT_CONTROLLER_UPDATE__START_TIME = 417,
    AXIS__TASK_TIMES__CURRENT_CONTROLLER_UPDATE__END_TIME = 418,
    AXIS__TASK_TIMES__CURRENT_CONTROLLER_UPDATE__LENGTH = 419,
    AXIS__TASK_TIMES__CURRENT_CONTROLLER_UPDATE__MAX_LENGTH = 420,
    AXIS__TASK_TIMES__DC_CALIB__START_TIME = 421,
    AXIS__TASK_TIMES__DC_CALIB__END_TIME = 422,
    AXIS__TASK_TIMES__DC_CALIB__LENGTH = 423,
    AXIS__TASK_TIMES__DC_CALIB__MAX_LENGTH = 424,
    AXIS__TASK_TIMES__CURRENT_SENSE__START_TIME = 425,
    AXIS__TASK_TIMES__CURRENT_SENSE__END_TIME = 426,
    AXIS__TASK_TIMES__CURRENT_SENSE__LENGTH = 427,
    AXIS__TASK_TIMES__CURRENT_SENSE__MAX_LENGTH = 428,
    AXIS__TASK_TIMES__PWM_UPDATE__START_TIME = 429,
    AXIS__TASK_TIMES__PWM_UPDATE__END_TIME = 430,
    AXIS__TASK_TIMES__PWM_UPDATE__LENGTH = 431,
    AXIS__TASK_TIMES__PWM_UPDATE__MAX_LENGTH = 432,
    AXIS__WATCHDOG_FEED = 433,
};

template<int I>
struct endpoint_type;

template<> struct endpoint_type<ERROR> { typedef uint8_t type; };
template<> struct endpoint_type<VBUS_VOLTAGE> { typedef float type; };
template<> struct endpoint_type<IBUS> { typedef float type; };
template<> struct endpoint_type<IBUS_REPORT_FILTER_K> { typedef float type; };
template<> struct endpoint_type<SERIAL_NUMBER> { typedef uint64_t type; };
template<> struct endpoint_type<HW_VERSION_MAJOR> { typedef uint8_t type; };
template<> struct endpoint_type<HW_VERSION_MINOR> { typedef uint8_t type; };
template<> struct endpoint_type<HW_VERSION_VARIANT> { typedef uint8_t type; };
template<> struct endpoint_type<FW_VERSION_MAJOR> { typedef uint8_t type; };
template<> struct endpoint_type<FW_VERSION_MINOR> { typedef uint8_t type; };
template<> struct endpoint_type<FW_VERSION_REVISION> { typedef uint8_t type; };
template<> struct endpoint_type<FW_VERSION_UNRELEASED> { typedef uint8_t type; };
template<> struct endpoint_type<BRAKE_RESISTOR_ARMED> { typedef bool type; };
template<> struct endpoint_type<BRAKE_RESISTOR_SATURATED> { typedef bool type; };
template<> struct endpoint_type<BRAKE_RESISTOR_CURRENT> { typedef float type; };
template<> struct endpoint_type<N_EVT_SAMPLING> { typedef uint32_t type; };
template<> struct endpoint_type<N_EVT_CONTROL_LOOP> { typedef uint32_t type; };
template<> struct endpoint_type<TASK_TIMERS_ARMED> { typedef bool type; };
template<> struct endpoint_type<TASK_TIMES__SAMPLING__START_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<TASK_TIMES__SAMPLING__END_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<TASK_TIMES__SAMPLING__LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<TASK_TIMES__SAMPLING__MAX_LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<TASK_TIMES__CONTROL_LOOP_MISC__START_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<TASK_TIMES__CONTROL_LOOP_MISC__END_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<TASK_TIMES__CONTROL_LOOP_MISC__LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<TASK_TIMES__CONTROL_LOOP_MISC__MAX_LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<TASK_TIMES__CONTROL_LOOP_CHECKS__START_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<TASK_TIMES__CONTROL_LOOP_CHECKS__END_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<TASK_TIMES__CONTROL_LOOP_CHECKS__LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<TASK_TIMES__CONTROL_LOOP_CHECKS__MAX_LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<TASK_TIMES__DC_CALIB_WAIT__START_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<TASK_TIMES__DC_CALIB_WAIT__END_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<TASK_TIMES__DC_CALIB_WAIT__LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<TASK_TIMES__DC_CALIB_WAIT__MAX_LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__UPTIME> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MIN_HEAP_SPACE> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MAX_STACK_USAGE_AXIS> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MAX_STACK_USAGE_USB> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MAX_STACK_USAGE_UART> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MAX_STACK_USAGE_CAN> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MAX_STACK_USAGE_STARTUP> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MAX_STACK_USAGE_ANALOG> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__STACK_SIZE_AXIS> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__STACK_SIZE_USB> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__STACK_SIZE_UART> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__STACK_SIZE_STARTUP> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__STACK_SIZE_CAN> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__STACK_SIZE_ANALOG> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__PRIO_AXIS> { typedef int32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__PRIO_USB> { typedef int32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__PRIO_UART> { typedef int32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__PRIO_STARTUP> { typedef int32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__PRIO_CAN> { typedef int32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__PRIO_ANALOG> { typedef int32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__USB__RX_CNT> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__USB__TX_CNT> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__USB__TX_OVERRUN_CNT> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__I2C__ADDR> { typedef uint8_t type; };
template<> struct endpoint_type<SYSTEM_STATS__I2C__ADDR_MATCH_CNT> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__I2C__RX_CNT> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__I2C__ERROR_CNT> { typedef uint32_t type; };
template<> struct endpoint_type<USER_CONFIG_LOADED> { typedef uint32_t type; };
template<> struct endpoint_type<MISCONFIGURED> { typedef bool type; };
template<> struct endpoint_type<OSCILLOSCOPE__SIZE> { typedef uint32_t type; };
template<> struct endpoint_type<CAN__ERROR> { typedef uint8_t type; };
template<> struct endpoint_type<CAN__CONFIG__BAUD_RATE> { typedef uint32_t type; };
template<> struct endpoint_type<CAN__CONFIG__PROTOCOL> { typedef uint8_t type; };
template<> struct endpoint_type<TEST_PROPERTY> { typedef uint32_t type; };
template<> struct endpoint_type<OTP_VALID> { typedef bool type; };
template<> struct endpoint_type<CONFIG__ENABLE_UART_A> { typedef bool type; };
template<> struct endpoint_type<CONFIG__ENABLE_UART_B> { typedef bool type; };
template<> struct endpoint_type<CONFIG__ENABLE_UART_C> { typedef bool type; };
template<> struct endpoint_type<CONFIG__UART_A_BAUDRATE> { typedef uint32_t type; };
template<> struct endpoint_type<CONFIG__UART_B_BAUDRATE> { typedef uint32_t type; };
template<> struct endpoint_type<CONFIG__UART_C_BAUDRATE> { typedef uint32_t type; };
template<> struct endpoint_type<CONFIG__ENABLE_CAN_A> { typedef bool type; };
template<> struct endpoint_type<CONFIG__ENABLE_I2C_A> { typedef bool type; };
template<> struct endpoint_type<CONFIG__USB_CDC_PROTOCOL> { typedef uint8_t type; };
template<> struct endpoint_type<CONFIG__UART0_PROTOCOL> { typedef uint8_t type; };
template<> struct endpoint_type<CONFIG__UART1_PROTOCOL> { typedef uint8_t type; };
template<> struct endpoint_type<CONFIG__UART2_PROTOCOL> { typedef uint8_t type; };
template<> struct endpoint_type<CONFIG__MAX_REGEN_CURRENT> { typedef float type; };
template<> struct endpoint_type<CONFIG__BRAKE_RESISTANCE> { typedef float type; };
template<> struct endpoint_type<CONFIG__ENABLE_BRAKE_RESISTOR> { typedef bool type; };
template<> struct endpoint_type<CONFIG__DC_BUS_UNDERVOLTAGE_TRIP_LEVEL> { typedef float type; };
template<> struct endpoint_type<CONFIG__DC_BUS_OVERVOLTAGE_TRIP_LEVEL> { typedef float type; };
template<> struct endpoint_type<CONFIG__ENABLE_DC_BUS_OVERVOLTAGE_RAMP> { typedef bool type; };
template<> struct endpoint_type<CONFIG__DC_BUS_OVERVOLTAGE_RAMP_START> { typedef float type; };
template<> struct endpoint_type<CONFIG__DC_BUS_OVERVOLTAGE_RAMP_END> { typedef float type; };
template<> struct endpoint_type<CONFIG__DC_MAX_POSITIVE_CURRENT> { typedef float type; };
template<> struct endpoint_type<CONFIG__DC_MAX_NEGATIVE_CURRENT> { typedef float type; };
template<> struct endpoint_type<CONFIG__ERROR_GPIO_PIN> { typedef uint32_t type; };
template<> struct endpoint_type<CONFIG__GPIO3_ANALOG_MAPPING__MIN> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO3_ANALOG_MAPPING__MAX> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO4_ANALOG_MAPPING__MIN> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO4_ANALOG_MAPPING__MAX> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO1_MODE> { typedef uint8_t type; };
template<> struct endpoint_type<CONFIG__GPIO2_MODE> { typedef uint8_t type; };
template<> struct endpoint_type<CONFIG__GPIO3_MODE> { typedef uint8_t type; };
template<> struct endpoint_type<CONFIG__GPIO4_MODE> { typedef uint8_t type; };
template<> struct endpoint_type<CONFIG__GPIO5_MODE> { typedef uint8_t type; };
template<> struct endpoint_type<CONFIG__GPIO6_MODE> { typedef uint8_t type; };
template<> struct endpoint_type<CONFIG__GPIO7_MODE> { typedef uint8_t type; };
template<> struct endpoint_type<CONFIG__GPIO8_MODE> { typedef uint8_t type; };
template<> struct endpoint_type<CONFIG__GPIO9_MODE> { typedef uint8_t type; };
template<> struct endpoint_type<CONFIG__GPIO10_MODE> { typedef uint8_t type; };
template<> struct endpoint_type<CONFIG__GPIO11_MODE> { typedef uint8_t type; };
template<> struct endpoint_type<CONFIG__GPIO12_MODE> { typedef uint8_t type; };
template<> struct endpoint_type<CONFIG__GPIO13_MODE> { typedef uint8_t type; };
template<> struct endpoint_type<CONFIG__GPIO14_MODE> { typedef uint8_t type; };
template<> struct endpoint_type<CONFIG__GPIO15_MODE> { typedef uint8_t type; };
template<> struct endpoint_type<CONFIG__GPIO16_MODE> { typedef uint8_t type; };
template<> struct endpoint_type<CONFIG__GPIO1_PWM_MAPPING__MIN> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO1_PWM_MAPPING__MAX> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO2_PWM_MAPPING__MIN> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO2_PWM_MAPPING__MAX> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO3_PWM_MAPPING__MIN> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO3_PWM_MAPPING__MAX> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO4_PWM_MAPPING__MIN> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO4_PWM_MAPPING__MAX> { typedef float type; };
template<> struct endpoint_type<ERASE_CONFIGURATION> { typedef void type; };
template<> struct endpoint_type<REBOOT> { typedef void type; };
template<> struct endpoint_type<ENTER_DFU_MODE> { typedef void type; };
template<> struct endpoint_type<CLEAR_ERRORS> { typedef void type; };


// Per-axis endpoints
template<> struct endpoint_type<AXIS__ERROR> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__STEP_DIR_ACTIVE> { typedef bool type; };
template<> struct endpoint_type<AXIS__LAST_DRV_FAULT> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__STEPS> { typedef int64_t type; };
template<> struct endpoint_type<AXIS__CURRENT_STATE> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__REQUESTED_STATE> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__IS_HOMED> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__STARTUP_MOTOR_CALIBRATION> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__STARTUP_ENCODER_INDEX_SEARCH> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__STARTUP_ENCODER_OFFSET_CALIBRATION> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__STARTUP_CLOSED_LOOP_CONTROL> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__STARTUP_HOMING> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__ENABLE_STEP_DIR> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__STEP_DIR_ALWAYS_ON> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__ENABLE_SENSORLESS_MODE> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__WATCHDOG_TIMEOUT> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__ENABLE_WATCHDOG> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__STEP_GPIO_PIN> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__CONFIG__DIR_GPIO_PIN> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__CONFIG__CALIBRATION_LOCKIN__CURRENT> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__CALIBRATION_LOCKIN__RAMP_TIME> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__CALIBRATION_LOCKIN__RAMP_DISTANCE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__CALIBRATION_LOCKIN__ACCEL> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__CALIBRATION_LOCKIN__VEL> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__SENSORLESS_RAMP__CURRENT> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__SENSORLESS_RAMP__RAMP_TIME> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__SENSORLESS_RAMP__RAMP_DISTANCE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__SENSORLESS_RAMP__ACCEL> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__SENSORLESS_RAMP__VEL> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__SENSORLESS_RAMP__FINISH_DISTANCE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__SENSORLESS_RAMP__FINISH_ON_VEL> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__SENSORLESS_RAMP__FINISH_ON_DISTANCE> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__SENSORLESS_RAMP__FINISH_ON_ENC_IDX> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__GENERAL_LOCKIN__CURRENT> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__GENERAL_LOCKIN__RAMP_TIME> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__GENERAL_LOCKIN__RAMP_DISTANCE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__GENERAL_LOCKIN__ACCEL> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__GENERAL_LOCKIN__VEL> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__GENERAL_LOCKIN__FINISH_DISTANCE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__GENERAL_LOCKIN__FINISH_ON_VEL> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__GENERAL_LOCKIN__FINISH_ON_DISTANCE> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__GENERAL_LOCKIN__FINISH_ON_ENC_IDX> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__CAN__NODE_ID> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__CONFIG__CAN__IS_EXTENDED> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__CAN__HEARTBEAT_RATE_MS> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__CONFIG__CAN__ENCODER_RATE_MS> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__MOTOR__LAST_ERROR_TIME> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__ERROR> { typedef uint64_t type; };
template<> struct endpoint_type<AXIS__MOTOR__IS_ARMED> { typedef bool type; };
template<> struct endpoint_type<AXIS__MOTOR__IS_CALIBRATED> { typedef bool type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_MEAS_PHA> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_MEAS_PHB> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_MEAS_PHC> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__DC_CALIB_PHA> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__DC_CALIB_PHB> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__DC_CALIB_PHC> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__I_BUS> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__PHASE_CURRENT_REV_GAIN> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__EFFECTIVE_CURRENT_LIM> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__MAX_ALLOWED_CURRENT> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__MAX_DC_CALIB> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__FET_THERMISTOR__TEMPERATURE> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__FET_THERMISTOR__CONFIG__TEMP_LIMIT_LOWER> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__FET_THERMISTOR__CONFIG__TEMP_LIMIT_UPPER> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__FET_THERMISTOR__CONFIG__ENABLED> { typedef bool type; };
template<> struct endpoint_type<AXIS__MOTOR__MOTOR_THERMISTOR__TEMPERATURE> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__MOTOR_THERMISTOR__CONFIG__GPIO_PIN> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__MOTOR_THERMISTOR__CONFIG__POLY_COEFFICIENT_0> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__MOTOR_THERMISTOR__CONFIG__POLY_COEFFICIENT_1> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__MOTOR_THERMISTOR__CONFIG__POLY_COEFFICIENT_2> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__MOTOR_THERMISTOR__CONFIG__POLY_COEFFICIENT_3> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__MOTOR_THERMISTOR__CONFIG__TEMP_LIMIT_LOWER> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__MOTOR_THERMISTOR__CONFIG__TEMP_LIMIT_UPPER> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__MOTOR_THERMISTOR__CONFIG__ENABLED> { typedef bool type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__P_GAIN> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__I_GAIN> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__I_MEASURED_REPORT_FILTER_K> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__ID_SETPOINT> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__IQ_SETPOINT> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__VD_SETPOINT> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__VQ_SETPOINT> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__PHASE> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__PHASE_VEL> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__IALPHA_MEASURED> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__IBETA_MEASURED> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__ID_MEASURED> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__IQ_MEASURED> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__POWER> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__V_CURRENT_CONTROL_INTEGRAL_D> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__V_CURRENT_CONTROL_INTEGRAL_Q> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__FINAL_V_ALPHA> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__FINAL_V_BETA> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__N_EVT_CURRENT_MEASUREMENT> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__MOTOR__N_EVT_PWM_UPDATE> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__PRE_CALIBRATED> { typedef bool type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__POLE_PAIRS> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__CALIBRATION_CURRENT> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__RESISTANCE_CALIB_MAX_VOLTAGE> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__PHASE_INDUCTANCE> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__PHASE_RESISTANCE> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__TORQUE_CONSTANT> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__MOTOR_TYPE> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__CURRENT_LIM> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__CURRENT_LIM_MARGIN> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__TORQUE_LIM> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__INVERTER_TEMP_LIMIT_LOWER> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__INVERTER_TEMP_LIMIT_UPPER> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__REQUESTED_CURRENT_RANGE> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__CURRENT_CONTROL_BANDWIDTH> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__ACIM_GAIN_MIN_FLUX> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__ACIM_AUTOFLUX_MIN_ID> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__ACIM_AUTOFLUX_ENABLE> { typedef bool type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__ACIM_AUTOFLUX_ATTACK_GAIN> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__ACIM_AUTOFLUX_DECAY_GAIN> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__R_WL_FF_ENABLE> { typedef bool type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__BEMF_FF_ENABLE> { typedef bool type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__I_BUS_HARD_MIN> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__I_BUS_HARD_MAX> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__I_LEAK_MAX> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__DC_CALIB_TAU> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__ERROR> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__CONTROLLER__LAST_ERROR_TIME> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__INPUT_POS> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__INPUT_VEL> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__INPUT_TORQUE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__POS_SETPOINT> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__VEL_SETPOINT> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__TORQUE_SETPOINT> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__TRAJECTORY_DONE> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONTROLLER__VEL_INTEGRATOR_TORQUE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__ANTICOGGING_VALID> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONTROLLER__AUTOTUNING_PHASE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__GAIN_SCHEDULING_WIDTH> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__ENABLE_VEL_LIMIT> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__ENABLE_TORQUE_MODE_VEL_LIMIT> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__ENABLE_GAIN_SCHEDULING> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__ENABLE_OVERSPEED_ERROR> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__CONTROL_MODE> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__INPUT_MODE> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__POS_GAIN> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__VEL_GAIN> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__VEL_INTEGRATOR_GAIN> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__VEL_LIMIT> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__VEL_LIMIT_TOLERANCE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__VEL_RAMP_RATE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__TORQUE_RAMP_RATE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__CIRCULAR_SETPOINTS> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__CIRCULAR_SETPOINT_RANGE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__STEPS_PER_CIRCULAR_RANGE> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__HOMING_SPEED> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__INERTIA> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__AXIS_TO_MIRROR> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__MIRROR_RATIO> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__TORQUE_MIRROR_RATIO> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__LOAD_ENCODER_AXIS> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__INPUT_FILTER_BANDWIDTH> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__ANTICOGGING__INDEX> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__ANTICOGGING__PRE_CALIBRATED> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__ANTICOGGING__CALIB_ANTICOGGING> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__ANTICOGGING__CALIB_POS_THRESHOLD> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__ANTICOGGING__CALIB_VEL_THRESHOLD> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__ANTICOGGING__COGGING_RATIO> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__ANTICOGGING__ANTICOGGING_ENABLED> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__MECHANICAL_POWER_BANDWIDTH> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__ELECTRICAL_POWER_BANDWIDTH> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__SPINOUT_MECHANICAL_POWER_THRESHOLD> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__SPINOUT_ELECTRICAL_POWER_THRESHOLD> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__AUTOTUNING__FREQUENCY> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__AUTOTUNING__POS_AMPLITUDE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__AUTOTUNING__VEL_AMPLITUDE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__AUTOTUNING__TORQUE_AMPLITUDE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__MECHANICAL_POWER> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__ELECTRICAL_POWER> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__START_ANTICOGGING_CALIBRATION> { typedef void type; };
template<> struct endpoint_type<AXIS__ENCODER__ERROR> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__ENCODER__IS_READY> { typedef bool type; };
template<> struct endpoint_type<AXIS__ENCODER__INDEX_FOUND> { typedef bool type; };
template<> struct endpoint_type<AXIS__ENCODER__SHADOW_COUNT> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__ENCODER__COUNT_IN_CPR> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__ENCODER__INTERPOLATION> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__PHASE> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__POS_ESTIMATE> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__POS_ESTIMATE_COUNTS> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__POS_CIRCULAR> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__POS_CPR_COUNTS> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__DELTA_POS_CPR_COUNTS> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__HALL_STATE> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__ENCODER__VEL_ESTIMATE> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__VEL_ESTIMATE_COUNTS> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__CALIB_SCAN_RESPONSE> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__POS_ABS> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__ENCODER__SPI_ERROR_RATE> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__MODE> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__USE_INDEX> { typedef bool type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__INDEX_OFFSET> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__USE_INDEX_OFFSET> { typedef bool type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__FIND_IDX_ON_LOCKIN_ONLY> { typedef bool type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__ABS_SPI_CS_GPIO_PIN> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__CPR> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__PHASE_OFFSET> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__PHASE_OFFSET_FLOAT> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__DIRECTION> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__PRE_CALIBRATED> { typedef bool type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__ENABLE_PHASE_INTERPOLATION> { typedef bool type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__BANDWIDTH> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__CALIB_RANGE> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__CALIB_SCAN_DISTANCE> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__CALIB_SCAN_OMEGA> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__IGNORE_ILLEGAL_HALL_STATE> { typedef bool type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__HALL_POLARITY> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__HALL_POLARITY_CALIBRATED> { typedef bool type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__SINCOS_GPIO_PIN_SIN> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__SINCOS_GPIO_PIN_COS> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__ACIM_ESTIMATOR__ROTOR_FLUX> { typedef float type; };
template<> struct endpoint_type<AXIS__ACIM_ESTIMATOR__SLIP_VEL> { typedef float type; };
template<> struct endpoint_type<AXIS__ACIM_ESTIMATOR__PHASE_OFFSET> { typedef float type; };
template<> struct endpoint_type<AXIS__ACIM_ESTIMATOR__STATOR_PHASE_VEL> { typedef float type; };
template<> struct endpoint_type<AXIS__ACIM_ESTIMATOR__STATOR_PHASE> { typedef float type; };
template<> struct endpoint_type<AXIS__ACIM_ESTIMATOR__CONFIG__SLIP_VELOCITY> { typedef float type; };
template<> struct endpoint_type<AXIS__SENSORLESS_ESTIMATOR__ERROR> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__SENSORLESS_ESTIMATOR__PHASE> { typedef float type; };
template<> struct endpoint_type<AXIS__SENSORLESS_ESTIMATOR__PLL_POS> { typedef float type; };
template<> struct endpoint_type<AXIS__SENSORLESS_ESTIMATOR__PHASE_VEL> { typedef float type; };
template<> struct endpoint_type<AXIS__SENSORLESS_ESTIMATOR__VEL_ESTIMATE> { typedef float type; };
template<> struct endpoint_type<AXIS__SENSORLESS_ESTIMATOR__CONFIG__OBSERVER_GAIN> { typedef float type; };
template<> struct endpoint_type<AXIS__SENSORLESS_ESTIMATOR__CONFIG__PLL_BANDWIDTH> { typedef float type; };
template<> struct endpoint_type<AXIS__SENSORLESS_ESTIMATOR__CONFIG__PM_FLUX_LINKAGE> { typedef float type; };
template<> struct endpoint_type<AXIS__TRAP_TRAJ__CONFIG__VEL_LIMIT> { typedef float type; };
template<> struct endpoint_type<AXIS__TRAP_TRAJ__CONFIG__ACCEL_LIMIT> { typedef float type; };
template<> struct endpoint_type<AXIS__TRAP_TRAJ__CONFIG__DECEL_LIMIT> { typedef float type; };
template<> struct endpoint_type<AXIS__MIN_ENDSTOP__ENDSTOP_STATE> { typedef bool type; };
template<> struct endpoint_type<AXIS__MIN_ENDSTOP__CONFIG__GPIO_NUM> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MIN_ENDSTOP__CONFIG__ENABLED> { typedef bool type; };
template<> struct endpoint_type<AXIS__MIN_ENDSTOP__CONFIG__OFFSET> { typedef float type; };
template<> struct endpoint_type<AXIS__MIN_ENDSTOP__CONFIG__IS_ACTIVE_HIGH> { typedef bool type; };
template<> struct endpoint_type<AXIS__MIN_ENDSTOP__CONFIG__DEBOUNCE_MS> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__MAX_ENDSTOP__ENDSTOP_STATE> { typedef bool type; };
template<> struct endpoint_type<AXIS__MAX_ENDSTOP__CONFIG__GPIO_NUM> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MAX_ENDSTOP__CONFIG__ENABLED> { typedef bool type; };
template<> struct endpoint_type<AXIS__MAX_ENDSTOP__CONFIG__OFFSET> { typedef float type; };
template<> struct endpoint_type<AXIS__MAX_ENDSTOP__CONFIG__IS_ACTIVE_HIGH> { typedef bool type; };
template<> struct endpoint_type<AXIS__MAX_ENDSTOP__CONFIG__DEBOUNCE_MS> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__MECHANICAL_BRAKE__CONFIG__GPIO_NUM> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MECHANICAL_BRAKE__CONFIG__IS_ACTIVE_LOW> { typedef bool type; };
template<> struct endpoint_type<AXIS__MECHANICAL_BRAKE__ENGAGE> { typedef void type; };
template<> struct endpoint_type<AXIS__MECHANICAL_BRAKE__RELEASE> { typedef void type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__THERMISTOR_UPDATE__START_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__THERMISTOR_UPDATE__END_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__THERMISTOR_UPDATE__LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__THERMISTOR_UPDATE__MAX_LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__ENCODER_UPDATE__START_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__ENCODER_UPDATE__END_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__ENCODER_UPDATE__LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__ENCODER_UPDATE__MAX_LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__SENSORLESS_ESTIMATOR_UPDATE__START_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__SENSORLESS_ESTIMATOR_UPDATE__END_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__SENSORLESS_ESTIMATOR_UPDATE__LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__SENSORLESS_ESTIMATOR_UPDATE__MAX_LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__ENDSTOP_UPDATE__START_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__ENDSTOP_UPDATE__END_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__ENDSTOP_UPDATE__LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__ENDSTOP_UPDATE__MAX_LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__CAN_HEARTBEAT__START_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__CAN_HEARTBEAT__END_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__CAN_HEARTBEAT__LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__CAN_HEARTBEAT__MAX_LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__CONTROLLER_UPDATE__START_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__CONTROLLER_UPDATE__END_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__CONTROLLER_UPDATE__LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__CONTROLLER_UPDATE__MAX_LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__OPEN_LOOP_CONTROLLER_UPDATE__START_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__OPEN_LOOP_CONTROLLER_UPDATE__END_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__OPEN_LOOP_CONTROLLER_UPDATE__LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__OPEN_LOOP_CONTROLLER_UPDATE__MAX_LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__ACIM_ESTIMATOR_UPDATE__START_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__ACIM_ESTIMATOR_UPDATE__END_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__ACIM_ESTIMATOR_UPDATE__LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__ACIM_ESTIMATOR_UPDATE__MAX_LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__MOTOR_UPDATE__START_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__MOTOR_UPDATE__END_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__MOTOR_UPDATE__LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__MOTOR_UPDATE__MAX_LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__CURRENT_CONTROLLER_UPDATE__START_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__CURRENT_CONTROLLER_UPDATE__END_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__CURRENT_CONTROLLER_UPDATE__LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__CURRENT_CONTROLLER_UPDATE__MAX_LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__DC_CALIB__START_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__DC_CALIB__END_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__DC_CALIB__LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__DC_CALIB__MAX_LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__CURRENT_SENSE__START_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__CURRENT_SENSE__END_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__CURRENT_SENSE__LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__CURRENT_SENSE__MAX_LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__PWM_UPDATE__START_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__PWM_UPDATE__END_TIME> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__PWM_UPDATE__LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__TASK_TIMES__PWM_UPDATE__MAX_LENGTH> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__WATCHDOG_FEED> { typedef void type; };


template<int I>
using endpoint_type_t = typename endpoint_type<I>::type;

}

#endif // __ODRIVE_ENDPOINTS_HPP